# Формируется матрица F следующим образом: если в С количество положительных элементов в четных столбцах в области 2
# больше, чем количество отрицательных  элементов в нечетных столбцах в области 4, то поменять в С симметрично
# области 1 и 3 местами, иначе С и Е поменять местами несимметрично. При этом матрица А не меняется. После чего
# вычисляется выражение: (F+A)*AT – K * F. Выводятся по мере формирования А, F и все матричные операции последовательно.

#                           1
#    E    B            4         2
#    D    C                 3

from random import randint
N = int(input('Матрица размером NxN\nВведите N='))
while N < 5:
    print('Вы ввели число, не подходящие по условию, введите число N, большее или равное 5')
    N = int(input())
K = int(input('Коэффициент умножения на матрицу F\nВведите k='))
print()
print()
print('границы подматриц и областей не включаются')

arr = []
for i in range(N):
    arr.append([])
    for j in range(N):
        arr[i].append(randint(-10, 10))                           #заполнение матрицы А случайными числами от -10 до 10

print('A')
for i in range(N):                                                #вывод матрицы А
    for j in range(N):
        print('{:4d}'.format(arr[i][j]), end='')
    print()

frr = []
for i in range(N):                                                #заполнение матрици F элементами матрицы А
    frr.append([])
    for j in range(N):
        frr[i].append(arr[i][j])

A = 0
B = 0
for i in range((N + 1) // 2, N):
    for j in range((N + 1) // 2, N):
        x = i - ((N + 1) // 2)
        y = j - ((N + 1) // 2)
        if (y % 2 != 0) and (x - y < 0) and (x + y > (N // 2) - 1) and frr[i][j] > 0:#условие для 2 области подматрицы С
            A += 1
        if (y % 2 == 0) and (x - y > 0) and (x + y < (N // 2) - 1) and frr[i][j] < 0:#условие для 4 области подматрицы С
            B += 1
print('количество положительных чисел A в области 2\nа = ', A, '\nколичество отрицательных чисел B в области 4\nb = ', B)
if A > B:
    print('A > B')
    print('первое условие: поменять в С симметрично области 1 и 3 местами')
    for i in range((N + 1) // 2, ((N + 1) // 2) + (N // 4)): #смена элементов области 1 и 3 подматрици С
        x = i - ((N + 1) // 2)
        for j in range(((N + 1) // 2) + x + 1, N - x - 1):
            y = j - ((N + 1) // 2)
            frr[((N // 2) - 1) - x + ((N + 1) // 2)][((N // 2) - 1) - y + ((N + 1) // 2)], frr[i][j] = \
                frr[i][j], frr[((N // 2) - 1) - x + ((N + 1) // 2)][((N // 2) - 1) - y + ((N + 1) // 2)]
else:
    print('A <= B')
    print('второе условие: С и Е поменять местами несимметрично')
    for i in range(N // 2):                                   #смена элементов подматриц С и Е
        for j in range(N//2):
            frr[i][j], frr[i + ((N + 1) // 2)][j + ((N + 1) // 2)] = \
                frr[i + ((N + 1) // 2)][j + ((N + 1) // 2)], frr[i][j]

print('F')
for i in range(N):                                            #вывод матрици F
    for j in range(N):
        print('{:4d}'.format(frr[i][j]), end='')
    print()


print('F+A')
FA = []
for i in range(N):                                             #заготовка для суммы матриц А и F
    FA.append([])
    for j in range(N):
        FA[i].append(arr[i][j])

for i in range(N):                                             #складование элементов матриц А и F
    for j in range(N):
        FA[i][j] = arr[i][j] + frr[i][j]


for i in range(N):                                             #ввывод матрици равное сумме А и F = FA
    for j in range(N):
        print('{:4d}'.format(FA[i][j]), end='')
    print()

tran = []
for i in range(N):                                             #заготовка для транспонентной матрицы Аt
    tran.append([])
    for j in range(N):
        tran[i].append(arr[i][j])

for i in range(N):                                             #транспонирование матрицы А
    for j in range(N):
        tran[j][i] = arr[i][j]


print('AT')                                                    #вывод транспонентной матрици Аt
for i in range(N):
    for j in range(N):
        print('{:4d}'.format(tran[i][j]), end='')
    print()



print('FA * AT')

FAT = []                                                        #заготовка под матрицу равной произведению матриц FA и At = FAT
for i in range(N):
    FAT.append([])
    for j in range(N):
        FAT[i].append(frr[i][j])


for i in range(N):
    for j in range(N):
        for k in range(N):
            FAT[i][j] += FA[i][k] * tran[k][j]

for i in range(N):                                              #вывод матрицы FAT
    for j in range(N):
        print('{:4d}'.format(FAT[i][j]), end='')
    print()

print('K*F')
FK = []                                                        #заготовка под матрицу F умноженную на k
for i in range(N):
    FK.append([])
    for j in range(N):
        FK[i].append(frr[i][j])

for i in range(N):                                              #умножение элементов матрицы F на коэффициент k
    for j in range(N):
        FK[i][j] = k * frr[i][j]

for i in range(N):                                              #вывод матрици равное F*k = FK
    for j in range(N):
        print('{:4d}'.format(FK[i][j]), end='')
    print()

print('(F + A) * At - K * F')
fin = []                                                        #заготовка под матрицу равной FAT - FK
for i in range(N):
    fin.append([])
    for j in range(N):
        fin[i].append(frr[i][j])

for i in range(N):
    for j in range(N):
        fin[i][j] = FAT[i][j] - FK[i][j]

for i in range(N):                                              #вывод матрицы равной вырожению (F+A)*At - k * F =
    for j in range(N):
        print('{:4d}'.format(fin[i][j]), end='')
    print()

